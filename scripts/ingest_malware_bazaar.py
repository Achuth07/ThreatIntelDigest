import os
import requests
import zipfile
import io
import csv
import boto3
import psycopg2
from psycopg2 import extras
from datetime import datetime, timedelta
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configuration
MALWARE_BAZAAR_URL = "https://bazaar.abuse.ch/export/csv/recent/"
R2_BUCKET_NAME = os.getenv("R2_BUCKET_NAME")
R2_ENDPOINT_URL = os.getenv("R2_ENDPOINT_URL")
R2_ACCESS_KEY_ID = os.getenv("R2_ACCESS_KEY_ID")
R2_SECRET_ACCESS_KEY = os.getenv("R2_SECRET_ACCESS_KEY")
R2_ACCOUNT_ID = os.getenv("R2_ACCOUNT_ID")
DATABASE_URL = os.getenv("DATABASE_URL")

def get_db_connection():
    """Establishes a connection to the PostgreSQL database."""
    conn = psycopg2.connect(DATABASE_URL, sslmode='require')
    return conn

def upload_to_r2(content, filename):
    """Uploads content to Cloudflare R2."""
    endpoint_url = R2_ENDPOINT_URL
    if not endpoint_url and R2_ACCOUNT_ID:
        endpoint_url = f"https://{R2_ACCOUNT_ID}.r2.cloudflarestorage.com"
        
    if not all([R2_BUCKET_NAME, endpoint_url, R2_ACCESS_KEY_ID, R2_SECRET_ACCESS_KEY]):
        print("Skipping R2 upload: Missing credentials.")
        return

    s3 = boto3.client(
        's3',
        endpoint_url=endpoint_url,
        aws_access_key_id=R2_ACCESS_KEY_ID,
        aws_secret_access_key=R2_SECRET_ACCESS_KEY
    )
    
    try:
        s3.put_object(Bucket=R2_BUCKET_NAME, Key=f"malware/{filename}", Body=content)
        print(f"Successfully uploaded {filename} to R2.")
    except Exception as e:
        print(f"Failed to upload to R2: {e}")

def process_and_ingest():
    """Downloads, parses, and ingests malware data."""
    print("Downloading daily malware batch...")
    headers = {
        "User-Agent": "ThreatIntelDigest/1.0 (Research Project)"
    }
    response = requests.get(MALWARE_BAZAAR_URL, headers=headers)
    response.raise_for_status()
    
    print(f"Response status: {response.status_code}")

    # Archive raw content to R2
    today_str = datetime.now().strftime("%Y-%m-%d")
    upload_to_r2(response.content, f"{today_str}.csv")

    # Process CSV in-memory
    family_counts = {}
    
    print("Processing CSV data...")
    # Decode directly
    content = io.StringIO(response.content.decode('utf-8', errors='replace'))
    
    # Skip comments (lines starting with #)
    reader = csv.reader(filter(lambda x: not x.startswith('#'), content))
    
    for row in reader:
        if not row: continue
        
        try:
            # Index 8 is 'signature' (e.g., CobaltStrike, Heodo)
            if len(row) > 8:
                signature = row[8]
                if signature and signature != "n/a":
                     # Clean the signature: remove quotes and whitespace
                     signature = signature.replace('"', '').strip()
                     if signature and signature != "n/a":
                        family_counts[signature] = family_counts.get(signature, 0) + 1
        except Exception as e:
            continue

    print(f"Aggregated {len(family_counts)} unique malware families.")

    if not family_counts:
        print("No malware families found to insert.")
        return

    # Insert into Database
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        current_date = datetime.now().date()
        malware_type = "Malware"
        
        # Prepare data for bulk insertion
        data_to_insert = [
            (current_date, family, count, malware_type)
            for family, count in family_counts.items()
        ]
        
        query = """
            INSERT INTO malware_daily_stats (date, family_name, sample_count, malware_type)
            VALUES %s
            ON CONFLICT (date, family_name) 
            DO UPDATE SET sample_count = EXCLUDED.sample_count
        """
        
        extras.execute_values(cur, query, data_to_insert)
            
        conn.commit()
        print(f"Successfully inserted/updated {len(data_to_insert)} records into malware_daily_stats.")
        
    except Exception as e:
        conn.rollback()
        print(f"Database error: {e}")
        # Re-raise to fail the workflow
        raise e
    finally:
        cur.close()
        conn.close()

if __name__ == "__main__":
    process_and_ingest()
