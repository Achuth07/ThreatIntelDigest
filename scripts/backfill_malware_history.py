
import os
import requests
import psycopg2
import io
import zipfile
import csv
from datetime import datetime
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

DATABASE_URL = os.getenv("DATABASE_URL")
MALWARE_BAZAAR_FULL_URL = "https://bazaar.abuse.ch/export/csv/full/"

def get_db_connection():
    return psycopg2.connect(DATABASE_URL)

def process_and_backfill():
    print("Starting backfill process...")
    
    # 1. Connect to DB and Truncate
    conn = get_db_connection()
    cur = conn.cursor()
    print("Truncating malware_daily_stats table...")
    cur.execute("TRUNCATE TABLE malware_daily_stats RESTART IDENTITY;")
    conn.commit()

    # 2. Download Full Export
    print("Downloading full malware export (this may take a while)...")
    with requests.get(MALWARE_BAZAAR_FULL_URL, stream=True) as r:
        r.raise_for_status()
        
        # 3. Process ZIP Stream
        with zipfile.ZipFile(io.BytesIO(r.content)) as z:
            csv_filename = z.namelist()[0]
            print(f"Processing {csv_filename}...")
            
            with z.open(csv_filename) as f:
                content = io.TextIOWrapper(f, encoding='utf-8', errors='replace')
                reader = csv.reader(filter(lambda x: not x.startswith('#'), content))
                
                # Aggregation: stats[date_str][family] = count
                stats = {}
                row_count = 0
                
                for row in reader:
                    # Expected columns (approx): first_seen_utc(0), sha256_hash(1), ..., signature(8)
                    if not row or len(row) < 9:
                        continue
                        
                    first_seen = row[0] # e.g. "2023-10-27 10:00:00"
                    signature = row[8]  # e.g. "CobaltStrike"
                    
                    if not signature or signature == "n/a":
                        continue
                        
                    # Clean signature
                    signature = signature.replace('"', '').strip()
                    if not signature or signature == "n/a":
                        continue

                    # Extract Date (YYYY-MM-DD)
                    try:
                        date_str = first_seen.split(' ')[0]
                    except:
                        continue
                        
                    if date_str not in stats:
                        stats[date_str] = {}
                    
                    stats[date_str][signature] = stats[date_str].get(signature, 0) + 1
                    row_count += 1
                    
                    if row_count % 100000 == 0:
                        print(f"Processed {row_count} rows...")

    print(f"Aggregation complete. Processed {row_count} total rows.")
    print(f"Found data for {len(stats)} days.")

    # 4. Bulk Insert
    print("Inserting aggregated data into database...")
    insert_query = """
        INSERT INTO malware_daily_stats (date, family_name, sample_count, malware_type, created_at)
        VALUES (%s, %s, %s, 'Malware', NOW())
    """
    
    records_to_insert = []
    
    for date_str, families in stats.items():
        # Optional: Skip incomplete data for today if needed, but for history it's fine.
        # Ensure date validity?
        try:
             # Just simple validation
             datetime.strptime(date_str, "%Y-%m-%d")
        except:
            continue

        for family, count in families.items():
            records_to_insert.append((date_str, family, count))
            
    # Batch insert
    batch_size = 1000
    total_records = len(records_to_insert)
    print(f"Total records to insert: {total_records}")
    
    for i in range(0, total_records, batch_size):
        batch = records_to_insert[i:i + batch_size]
        cur.executemany(insert_query, batch)
        conn.commit()
        if i % 10000 == 0:
            print(f"Inserted {i}/{total_records} records...")

    print("Backfill complete!")
    cur.close()
    conn.close()

if __name__ == "__main__":
    process_and_backfill()
